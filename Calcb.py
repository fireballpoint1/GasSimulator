def CALCB(NVAC,KGAS,LGAS,ELECEN,ISHELL):
	# IMPLICIT #real*8(A-H,O-Z)
	# IMPLICIT #integer*8(I-N)
	# CHARACTER*6 SCR(17),SCR1(17)
	# COMMON/PRIM4/MSUM1,MCOMP1,MRAYL1,MPAIR1,MPHOT1,MVAC1
	# COMMON/GENCAS/ELEV[17,79],NSDEG(17),AA[17],BB[17],SCR,SCR1
	# COMMON/MIXC/PRSH(6,3,17,17),ESH(6,3,17),AUG(6,3,17,17,17),RAD[6,3,17,17],PRSHBT(6,3,17),IZ[6,3],INIOCC(6,3,17),ISHLMX(6,3),AMZ[6,3]
	# COMMON/UPD/NOCC(6,3,17),AUGR(6,3,17,17,17),RADR(6,3,17,17)
	# COMMON/CALCASB/IONSUM(10),IFLSUM(10),ESTORE(10,28),EPHOTON(10,28),DRXE(10,28),DRYE(10,28),DRZE(10,28),DRX(10,28),DRY(10,28),DRZ[10,28]
     #COMMON/PRIM4/
     global MSUM1,MCOMP1,MRAYL1,MPAIR1,MPHOT1,MVAC1
     #COMMON/GENCAS/
     global ELEV#[17,79]
     global NSDEG#(17)
     global AA#[17]
     global BB#[17]
     global SCR,SCR1
     #COMMON/MIXC/
     global PRSH#(6,3,17,17)
     global ESH#(6,3,17)
     global AUG#(6,3,17,17,17)
     global RAD#[6,3,17,17]
     global PRSHBT#(6,3,17)
     global IZ#[6,3]
     global INIOCC#(6,3,17)
     global ISHLMX#(6,3)
     global AMZ#[6,3]
     #COMMON/UPD/
     global NOCC#(6,3,17)
     global AUGR#(6,3,17,17,17)
     global RADR#(6,3,17,17)
     #COMMON/CALCASB/
     global IONSUM#(10)
     global IFLSUM#(10)
     global ESTORE#(10,28)
     global EPHOTON#(10,28)
     global DRXE#(10,28)
     global DRYE#(10,28)
     global DRZE#(10,28)
     global DRX#(10,28)
     global DRY#(10,28)
     global DRZ#[10,28]
	
	#DIMENSION 
	TEMP=[0 for x in range(17)]
	TEMP1=[0 for x in range(289)]
	#
	# CALCULATE CASCADE IN GAS KGAS AND MOLECULAR COMPONENT LGAS
	# WITH INTIAL ENERGY DEPOSIT ELECEN AND SHELL VACANCY CREATED AT ISHELL
	#
	# INITIAL PHOTON DIRECTION  DRX, DRY AND DRZ
	DRXINIT=DRXE(NVAC,1)
	DRYINIT=DRYE(NVAC,1)
	DRZINIT=DRZE(NVAC,1)
	ISHELLST=ISHELL
	100 ELEFT=ELECEN
	ISHELL=ISHELLST
	API=numpy.arccos(-1.00)
	TWOPI=2.00*API
	ISECOND=1
	ifIRST=0:
	# SET STARTING ARRAY NOCC EQUAL TO INIOCC
	DO 1 I=1,17
	NOCC[KGAS][LGAS][I]=INIOCC(KGAS,LGAS,I)
	1 CONTINUE
	# PHOTONS
	IONSUM[NVAC]=1
	IFLSUM[NVAC]:
	=0
	# STORE INITIAL PHOTOELECTRON ENERGY AND ANGLE
	ESTORE(NVAC,1)=ELECEN-ELEV[ISHELL,IZ[KGAS][LGAS]]
	ELECN=ESTORE(NVAC,1)
	ELEFT=ELEFT-ESTORE(NVAC,1)
	NOCC[KGAS][LGAS][ISHELL]=NOCC[KGAS][LGAS][ISHELL]-1  
	#    ENTRY FOR COMPTON ELECTRON.....
	if(NVAC <= MCOMP1):
	:
	#    IF COMPTON EVENT ELECTRON ANGLE FROM COMPTON (ALREADY STORED)
	GO TO 4
	# endif
	# USE PHOTOELCTRON ANGULAR DISTRIBUTION
	APE=AA[ISHELL]
	BPE=BB[ISHELL]
	CALL ANGGEN(APE,BPE,THET)
	if(THET < 0.0):
	THET=THET+API
	R3=DRAND48(RDUM)
	PHI=TWOPI*R3
	# INITIAL PHOTON DIRECTION  DRXINIT, DRYINIT AND DRZINIT
	CALL DRCOS(DRXINIT,DRYINIT,DRZINIT,THET,PHI,DRXX,DRYY,DRZZ)
	DRXE(NVAC,1)=DRXX
	DRYE(NVAC,1)=DRYY
	DRZE(NVAC,1)=DRZZ
	4 CONTINUE
	# CHECK FOR ELECTRON SHAKEOFF
	ICON=1
	ifIRST=ifIRST+1:
	if(ifIRST > 1):
	ELECN=ESTORE(NVAC,IONSUM[NVAC])
	CALL SHAKE(ISHELL,ELECN,KGAS,LGAS,ESHK,ICON,ifIRST,JVAC)
	#  CALCULATE ENERGY OF ELECTRON
	if(JVAC == 0):
	GO TO 2
	if(ifIRST == 1):
	:
	# INITIAL ELECTRON + SHAKEOFF
	ELECN=ELECN-ESHK-ELEV[JVAC,IZ[KGAS][LGAS]]
	# PRIMARY ELECTRON
	ESTORE(NVAC,IONSUM[NVAC])=ELECN
	# endif
	if(ifIRST != 1):
	:
	ESTORE(NVAC,IONSUM[NVAC])=ESTORE(NVAC,IONSUM[NVAC])-ESHK-ELEV[JVAC,IZ[KGAS][LGAS]]
	# endif
	IONSUM[NVAC]=IONSUM[NVAC]+1
	# MAXIMUM ION CHARGE STATE =28
	if(IONSUM[NVAC]:
	> 28) :
	WRITE(6,99) IONSUM[NVAC] 
	99  print(' WARNING ION CHARGE LIMITED TO 28+ IN THIS VERSION') 
	sys.exit()
	# endif
	# SHAKE ELECTRON
	ESTORE(NVAC,IONSUM[NVAC])=ESHK
	ELEFT=ELEFT-ESHK-ELEV[JVAC,IZ[KGAS][LGAS]]
	if(ELEFT < 0.0):
	GO TO 100
	# RANDOM EMISSION DIRECTION
	R3=DRAND48(RDUM)
	THET=numpy.arccos(1.0-2.0*R3)
	R3=DRAND48(RDUM)
	PHI=TWOPI*R3
	DRXE[NVAC][IONSUM[NVAC]]=numpy.sin(THET)*numpy.cos(PHI)
	DRYE[NVAC][IONSUM[NVAC]]=numpy.sin(THET)*numpy.sin(PHI)
	DRZE[NVAC][IONSUM[NVAC]]=numpy.cos(THET)
	2 CONTINUE                                     
	CALL UPDATE(KGAS,LGAS,ISHELL)
	#  CHOOSE FLUORESCENCE OR AUGER TRANSITION
	TSUM=0.0
	DO 10 I=1,17
	TSUM=TSUM+RADR(KGAS,LGAS,ISHELL,I)
	DO 10 J=1,17
	TSUM=TSUM+AUGR(KGAS,LGAS,ISHELL,I,J)
	10 CONTINUE
	# NO MORE TRANSITIONS POSSIBLE
	if(TSUM == 0.0):
	return  
	# NORMALISE TO 1.0
	DO 11 I=1,17
	RADR(KGAS,LGAS,ISHELL,I)=RADR(KGAS,LGAS,ISHELL,I)/TSUM
	DO 11 J=1,17
	AUGR(KGAS,LGAS,ISHELL,I,J)=AUGR(KGAS,LGAS,ISHELL,I,J)/TSUM
	11 CONTINUE
	# CREATE CUMULATIVE SUM ARRAY
	TEMP[1]=RADR(KGAS,LGAS,ISHELL,1)
	DO 12 I=2,17
	TEMP[I]=RADR(KGAS,LGAS,ISHELL,I)+TEMP(I-1)
	12 CONTINUE
	TEMP1[1]=AUGR(KGAS,LGAS,ISHELL,1,1)
	DO 13 I=2,17
	TEMP1[I]=AUGR(KGAS,LGAS,ISHELL,I,1)+TEMP1(I-1)
	13 CONTINUE
	DO 14 J=1,16
	DO 14 I=1,17
	TEMP1(I+(J*17))=AUGR(KGAS,LGAS,ISHELL,I,(J+1))+TEMP1(I+(J*17)-1)
	14 CONTINUE
	# FIND FLUORESCENCE OR AUGER TRANSITION
	R1=DRAND48(RDUM)
	DO 16 I=1,17
	if(R1 < TEMP[I]:
	) :
	# STORE PHOTON ENERGY AND ANGLE : UPDATE NOCC
	IFLSUM[NVAC]:
	=IFLSUM[NVAC]+1
	EPHOTON(NVAC,IFLSUM[NVAC])=ELEV[ISHELL,IZ[KGAS][LGAS]]-ELEV[I,IZ[KGAS][LGAS]]
	ELEFT=ELEFT-abs(EPHOTON(NVAC,IFLSUM[NVAC]))
	if(ELEFT < 0.0):
	GO TO 100
	# RANDOM EMISSION DIRECTION
	R3=DRAND48(RDUM)
	THET=numpy.arccos(1.0-2.0*R3)
	R3=DRAND48(RDUM)
	PHI=TWOPI*R3
	# CALC DIRECTION COSINES OF FLUORESCENCE
	DRX[NVAC][IFLSUM[NVAC]]=numpy.sin(THET)*numpy.cos(PHI)
	DRY[NVAC][IFLSUM[NVAC]]=numpy.sin(THET)*numpy.sin(PHI)
	DRZ[NVAC][IFLSUM[NVAC]]=numpy.cos(THET)
	#   
	NOCC[KGAS][LGAS][ISHELL]=NOCC[KGAS][LGAS][ISHELL]+1
	NOCC[KGAS][LGAS][I]=NOCC[KGAS][LGAS][I]-1
	# FIND LOWEST VACANCY
	CALL VACANCY(KGAS,LGAS,ISHELL,ILAST)
	if(ILAST == 1):
	:
	# NO MORE TRANSITIONS POSSIBLE
	return    
	# endif
	GO TO 2  
	# endif 
	16 CONTINUE
	116 CONTINUE
	R2=R1-TEMP(17)
	DO 27 J=1,17
	DO 27 I=1,17
	if(R2 < TEMP1(I+((J-1):
	*17))) :
	# AUGER OR COSTER KRONIG  
	# STORE EJECTED ELECTRON AND UPDATE NOCC
	ETEMP=ELEV[ISHELL,IZ[KGAS][LGAS]]-(ELEV[I,IZ[KGAS][LGAS]]+ELEV[I,IZ[KGAS][LGAS]+1])*0.5-(ELEV[J,IZ[KGAS][LGAS]]+ELEV[J,IZ[KGAS][LGAS]+1])*0.5
	if(ETEMP < 0.0):
	:
	# DO NOT ALLOW NEGATIVE ENERGY TRANSITIONS
	117   R1=DRAND48(RDUM)
	if(R1 < TEMP(17):
	) GO TO 117
	GO TO 116
	# endif
	IONSUM[NVAC]=IONSUM[NVAC]+1
	if(IONSUM[NVAC]:
	> 28) : 
	WRITE(6,887) IONSUM[NVAC]
	887   print(' IONSUM LIMITED TO 28 IN THIS VERSION IONSUM=',I3,' IN CALCB')
	sys.exit()
	# endif
	ESTORE(NVAC,IONSUM[NVAC])=ETEMP
	ELEFT=ELEFT-abs(ETEMP)
	if(ELEFT < 0.0):
	GO TO 100
	# RANDOM EMISSION DIRECTION
	R3=DRAND48(RDUM)
	THET=numpy.arccos(1.0-2.0*R3)
	R3=DRAND48(RDUM)
	PHI=TWOPI*R3
	DRXE[NVAC][IONSUM[NVAC]]=numpy.sin(THET)*numpy.cos(PHI)
	DRYE[NVAC][IONSUM[NVAC]]=numpy.sin(THET)*numpy.sin(PHI)
	DRZE[NVAC][IONSUM[NVAC]]=numpy.cos(THET)
	NOCC[KGAS][LGAS][ISHELL]=NOCC[KGAS][LGAS][ISHELL]+1
	NOCC[KGAS][LGAS][I]=NOCC[KGAS][LGAS][I]-1
	NOCC[KGAS][LGAS][J]=NOCC[KGAS][LGAS][J]-1
	# FIND LOWEST VACANCY
	CALL VACANCY(KGAS,LGAS,ISHELL,ILAST)
	if(ILAST == 1):
	:
	# NO MORE TRANSITIONS POSSIBLE
	return
	# endif
	GO TO 4 
	# endif
	27 CONTINUE
	WRITE(6,88) 
	88 print(' ERROR IN CASCADE 0 def CALCB') 
	sys.exit() 
	# end